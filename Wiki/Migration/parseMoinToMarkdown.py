#!/usr/local/bin/python3
# -*- coding: utf-8 -*-
#
# Attempting to parse everything, including whitespace.

import argparse
from pypeg2 import *                           # parser library.
import re
import os

# What are the different types of things we hit in MoinMarkup?




# ################
# Basic Text
# ################

class TrailingWhitespace(List):
    grammar = contiguous(re.compile(r"[ \t\f\v]*\n", re.MULTILINE))

    def compose(self, parser, attr_of):
        return ("\n")


class Punctuation(List):
    """
    Characters that aren't included in plaintext or other tokens

    Matches a single character.
    Prevent matching with table cell ending.
    """
    grammar = contiguous(
        attr("punctuation", re.compile(r"([^\w\s\|])|(\|(?=[^\|]|$))")))
    

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return(self.punctuation)

    def composeHtml(self):
        """
        For now use same as Markdown.
        """
        return(compose(self))

        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        # What should work
        parse(".", cls)
        parse("/", cls)
        parse("?", cls)
        parse("|", cls)

        # What should not work
        testFail("||", cls)
        testFail(" OK[", cls)
        testFail(" ", cls)
        testFail("<<", cls)
        testFail("Uh-huh, this text does'nt mean anything. [[", cls)
        testFail("}}", cls)


class InlineComment(List):
    """
    Moin inline comments either
      Start with /* and run to the end of the line
      Start with /* and end with */ on the same line

    Markdown does not support comments, but YAML does:
      Comments begin with the number sign ( # ), can start anywhere on a line,
      and continue until the end of the line

    TODO: Investigate putting inline comments in the YAML parts of the files.
    """
    grammar = contiguous(
        "/*",
        attr("comment", re.compile(r".*?(?=\*/|\n)")),
        ["*/", restline])   

    def compose(self, parser, attr_of):
        """
        GFM does not appear to support comments.

        Which is unfortuanate as most of these comments are there for a reason.
        See above TODO.
        """
        return("")

    def composeHtml(self):
        """
        For now use same as Markdown.
        """
        return(compose(self))


                
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        # What should work
        parse("/*\n", cls)
        parse("/* This is a comment */", cls)

        # What should not work
        testFail("*/ Oops comment start backwards */", cls)

class Comment(List):
    """
    Moin comments start with ## in the first two columns.

    Given that PyPeg strips leading whitespace, I'm not sure how to tell when
    lines start with ##.
    """
    grammar = contiguous(
        "##",
        optional(re.compile(r" *"),
            optional(attr("comment", re.compile(r".+")))),
        TrailingWhitespace)
    

    def compose(self, parser, attr_of):
        """
        GFM does not appear to support comments.

        Most were generated by MoinMoin automatically, and arent that helpful
        anyway.
        """
        return("")

    def composeHtml(self):
        """
        For now use same as Markdown.
        """
        return(compose(self))


    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        # What should work
        parse("##\n", cls)
        parse("## \n", cls)
        parse("## I sing the body ...\n", cls)
        parse("## page was renamed from Admin/Disk Quotas\n", cls)

        # What should not work
        testFail("# Not a comment", cls)
        testFail("#format\n", cls)

        

# ============
# plain text
# ============

class PlainText(List):
    """
    Text with no special characters or punctuation in it.
    """
    grammar = contiguous(
        attr("text", re.compile(r"[\w \t\f\v]+")))

    
    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return(self.text)
        
    def composeHtml(self):
        """
        For now use same as Markdown.
        """
        return(compose(self))

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        # What should work
        parse(" Testing with no special terminator", cls)
        parse(" OK DOKE ", cls)

        # What should not work
        testFail(" OK DOKE[[", cls)
        testFail(" OK DOKE]]", cls)
        testFail(" OK DOKE. <<", cls)
        testFail("Uh-huh, this text does'nt mean anything. [[", cls)
        testFail(" OK DOKE}}", cls)
        testFail(" OK DOKE\n NOT! ", cls)

class QuotedString(List):
    """
    String embedded in quotes, single or double.

    Match includes the string.  Does not do the right thing with bolds or
    italics, so they must be matched before this.

    Only called when we expect to have a quoted string (like in a Macro).
    Using this in the general case wreaks havoc because of apostrophes.
    """
    grammar = contiguous(
        attr("quotedText",
             re.compile(r"""(?P<quote>['"])(?P<quotedText>.+?)(?P=quote)""")))


    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return(self.quotedText)

    def justTheString(self):
        """
        Return just the string, without the quotes.
        """
        return(self.quotedText[1:-1])

        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("'Jump'", cls)
        parse('''"I Can't do this no more!"''', cls)
        parse(r'"= LAPTOP WITH BROWSER ="', cls)


class Bold(List):
    """
    3 single quotes start and end bold in moinmoin
    """
    grammar = contiguous("'''")
    inBold = False

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return("**")

    def composeHtml(self):
        Bold.inBold = not Bold.inBold
        if Bold.inBold:
            return("<strong>")
        else:
            return("</strong>")

        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("'''", cls)


class Italic(List):
    """
    Two single quotes start and stop italics.

    This must be processed after Bold.
    """
    grammar = contiguous("''")
    inItalic = False

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return("*")


    def composeHtml(self):
        Italic.inItalic = not Italic.inItalic
        if Italic.inItalic:
            return("<em>")
        else:
            return("</em>")


                
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("''", cls)



class FontSizeChangeStart(List):
    """
    ~+ increases the font size, ~- decreases it

    Note: When viewing this in Github, the font doesn't actually change size,
    even though the HTML is correct.
    """
    grammar = contiguous("~", attr("direction", re.compile("\+|\-")))

    def compose(self, parser, attr_of):
        if self.direction == "+":
            newSize = "larger"
        else:
            newSize = "smaller"
        return('<span style="font-size: ' + newSize + ';">')
        
    def composeHtml(self):
        return(compose(self))
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("~+", cls)
        parse("~-", cls)


class FontSizeChangeEnd(List):
    """
    +~ / -~ finishes a change in font size
    """
    grammar = contiguous(re.compile("\+|\-"), "~")

    def compose(self, parser, attr_of):
        return('</span>')
        
    def composeHtml(self):
        return(compose(self))
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("+~", cls)
        parse("-~", cls)

        
class CodeBlockEnd(List):
    """
    }}} ends a code block.
    """
    grammar = contiguous("}}}")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return("```\n")
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("}}}", cls)

        
class Monospace(List):
    """
    Monospace is used to detect inline text that should be monospace.

    Can occur anywhwere that plain text can, and in Moin, markup inside monospace
    is rendered as plain text.
    """
    grammar = contiguous(
        re.compile(r"{{{|\`"),
        attr("monoText", re.compile(r".*?(?=}}}|\`)")),
        re.compile(r"}}}|\`"))
        
    def compose(self, parser, attr_of):
        return("`" + self.monoText + "`")


    def composeHtml(self):
        return("<code>" + self.monoText + "</code>")

                
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("{{{this is it!}}}", cls)
        parse("`this is it!`", cls)

        

class CodeBlockStart(List):
    """
    {{{ starts a code block.

    Can also specify language.
    {{{#!highlight ini
    {{{#!csv
    """
    grammar = contiguous(
        "{{{",
        optional("#!",
                 optional("highlight", re.compile(r" +")),
                 attr("format", re.compile(r"[^\s]+"))))

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        out = "\n```"
        if hasattr(self, "format"):
            out += self.format
        return(out)
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("{{{", cls)
        parse("{{{#!csv", cls)
        parse("{{{#!highlight ini", cls)


class CodeBlockEnd(List):
    """
    }}} ends a code block.
    """
    grammar = contiguous("}}}")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return("```\n")
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("}}}", cls)

        


# -------------
# PagePath - defined here instead of in Links b/c of dependencies
# -------------

class InternalPagePath(str):
    """
    path to an internal page.  Can be absolute or relative.

    Internal pages can match on fewer characters than external pages
    Used when we know we have a page name.

    Allowable characters for general URLs are
      ALPHA / DIGIT / "-" / "." / "_" / "~" 
      ":" / "/" / "?" / "#" / "[" / "]" / "@"  - can't handle [] internally
      "!" / "$" / "&" / "'" / "(" / ")"        - can't handle () ...
      / "*" / "+" / "," / ";" / "="            - can't handle ,  ...
      spaces
      % 
    in any combination
    See http://stackoverflow.com/questions/1856785/characters-allowed-in-a-url
    """
    grammar = contiguous(re.compile(r"[\w\-\.~:/?#@!\$&'\*+;= %]+"))


    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("FrontPage/Use Galaxy", cls)
        parse("FrontPage/Use Galaxy#This Part of the page", cls)
        parse("/Includes", cls)


class ExternalPagePath(str):
    """
    path to an external page.  

    Allowable characters are
      ALPHA / DIGIT / "-" / "." / "_" / "~" 
      ":" / "/" / "?" / "#" / "[" / "]" / "@"  - can't handle []
      "!" / "$" / "&" / "'" / "(" / ")"        
      / "*" / "+" / "," / ";" / "="
      spaces
      % 
    in any combination
    See http://stackoverflow.com/questions/1856785/characters-allowed-in-a-url
    """
    grammar = contiguous(re.compile(r"[\w\-\.~:/?#@!\$&'\(\)\*+, ;= %]+"))

    
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("FrontPage/Use Galaxy", cls)
        parse("FrontPage/Use Galaxy#This Part of the page", cls)
        parse("/Includes", cls)
        parse("developers.google.com/+/features/sign-in", cls)



        
# ################
# MACROS
# ################

class NamedMacroParameter(List):
    grammar = contiguous(
        r",", maybe_some(whitespace), name(), maybe_some(whitespace), "=",
        maybe_some(whitespace), QuotedString)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse(", fish='jump'", cls)
        parse(', fish="jump high"', cls)
        parse(', from="= LAPTOP WITH BROWSER ="', cls)


class EmptyMacroParameter(List):
    grammar = contiguous(r",")

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse(",", cls)
        parse(", ", cls)

               
class IncludeMacroParameter(List):
    """
    Include params after the page path can be
      empty
      from="some text"
      to="some text"
    and lots of other things we don't use.
    See https://moinmo.in/HelpOnMacros/Include
    """
    grammar = contiguous([NamedMacroParameter, EmptyMacroParameter, whitespace])

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        NamedMacroParameter.test()
        EmptyMacroParameter.test()
        parse(", fish='jump'", cls)
        parse(", ", cls)


class IncludeMacro(List):
    """
    Include Macros can have one or more params.
      <<Include(FrontPage/Use Galaxy)>>
      <<Include(/Includes, , from="= LAPTOP WITH =\n", to="\nEND_INCLUDE")>>
    The opening and closing << >> will have been stripped before parsing.
    """
    grammar = contiguous(
        "Include(",
        maybe_some(whitespace),
        attr("pagePath", InternalPagePath),
        maybe_some(whitespace),
        attr("params", maybe_some(IncludeMacroParameter)), ")")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        if self.params:
            return("INCLUDE(" + self.pagePath + self.params + ")")
        else:
            return("INCLUDE(" + self.pagePath + ")")

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        InternalPagePath.test()
        IncludeMacroParameter.test()
        parse("Include(FrontPage/Use Galaxy)", cls)
        parse(r'Include(/Includes, , from="= LAPTOP =", to="END_INCLUDE")', cls)
        parse('Include(/Includes, , from="= LAPTOP =\\n", to="\\nEND_INCLUDE")', cls)

class TitleDiv(List):
    """
    Title Div may get special handling because it might affect the YAML.
    """
    grammar = contiguous("title")

    def compose(self, parser, attr_of):
        return("""<div class="title">""")


        
class SpecialDiv(List):
    """
    Anything parsed by this requires something other than just generating a
    div tag.
    """
    grammar = contiguous(TitleDiv)


class OtherDiv(List):
    """
    Handles div classes that only need a div tag generated.
    """
    grammar = contiguous(
        attr("divClass", re.compile(r"\w+")))
        
    def compose(self, parser, attr_of):
        return("<div class='" + self.divClass + "'>")

        
class DivMacro(List):
    """
    Div Macros can define one or more local styles, or close a div
      <<div(solid blue)>>
      <<div(center)>>
      <<div>> (closing)
    Need to figure out what to do in each situation?  Maybe take advantage of
    CSS that we control?
    """
    grammar = contiguous(
        "div",
        optional("(", [SpecialDiv, OtherDiv],
            maybe_some(omit(whitespace), [SpecialDiv, OtherDiv]),
            ")"))

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        out = ""
        for divClass in self:
            out += compose(divClass)
        if len(self) == 0:
            out = "</div>"
        return(out)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("div(center)", cls)
        parse("div", cls)
        parse("div(indent)", cls)


class TOCMacro(List):
    """
    TableOfContents Macros insert TOC's.  There ya go.
      <<TableOfContents>>
      <<TableOfContents([maxdepth])>>
      <<TableOfContents(2)>>
    """
    grammar = contiguous(
        "TableOfContents",
        optional(
            "(", optional(attr("maxDepth", re.compile(r"\d+"))), ")"))

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        out = "TABLE_OF_CONTENTS"
        try:
            out += "(" + self.maxDepth + ")"
        except AttributeError:
            pass
        return(out)


    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("TableOfContents", cls)
        parse("TableOfContents(2)", cls)



class BRMacro(List):
    """
    BR macros insert a new line.
      <<BR>>

    That's it.
    """
    grammar = contiguous("BR")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return("<br />")

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("BR", cls)


class MailToMacro(List):
    """
    MailTo Macros look like
      <<MailTo(bioinformatics.core@ucdavis.edu, UC Davis Bioinformatics)>>
      <<MailTo(bioinformatics.core@ucdavis.edu)>>
      <<MailTo(bioinformatics.core AT ucdavis DOT edu, UC Davis Bioinformatics)>>
      <<MailTo(bioinformatics.core AT ucdavis DOT edu)>>
    """
    grammar = contiguous(
        "MailTo(",
        maybe_some(" "),
        attr("emailAddress", re.compile(r"[^\,\)]+")),
        optional(
            ",",
            maybe_some(" "),
            attr("toText", re.compile(r"[^\)]+")),
            maybe_some(" ")
            ),
        ")" )
            

    def compose(self, parser, attr_of):
        """
        Can be generated as a link in Markdown
        """
        out = "[" + self.emailAddress + "]"
        if hasattr(self, "toText"):
            out += "(" + self.toText + ")"
        else:
            out += "(" + self.emailAddress + ")"
        return(out)

    def composeHtml(self):
        out = '<a href="mailto:' + self.emailAddress + '">'
        if hasattr(self, "toText"):
            out += self.toText
        else:
            out += self.emailAddress
        out += "</a>"
        return(out)

        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("MailTo(q)", cls)
        parse("MailTo(bioinformatics.core@ucdavis.edu)", cls)
        parse("MailTo(bioinformatics.core@ucdavis.edu, UC Davis Bioinformatics)", cls)
        parse("MailTo(bioinformatics.core AT ucdavis.edu, UC Davis Bioinformatics)", cls)
        parse('MailTo( w4mcourse2015.organisation@sb-roscoff.fr, W4M Course Organisers)', cls)



class Macro(List):
    """
    MoinMoin can have macros link include, or div or TableOfContents.  Sometimes they
    have parameters.
      <<Include(FrontPage/Use Galaxy)>>
      <<div(center)>>
      <<TableOfContents>>
      <<div>>
      <<Include(/Includes, , from="= LAPTOP WITH =\n", to="\nEND_INCLUDE")>>
      TODO
    """
    grammar = contiguous(
        "<<",
        attr("macro",
            [TOCMacro, IncludeMacro, DivMacro, BRMacro, MailToMacro]),
        ">>")


    def compose(self, parser, attr_of):
        return(compose(self.macro))
    
    def composeHtml(self):
        """
        For cases when the subelement needs to be rendered in HTML (such as
        inside a table).
        """
        # for most macros, default to same markup as used in Markdown.
        if isinstance(self.macro, MailToMacro):
            return(self.macro.composeHtml())
        else:
            return(compose(self.macro))

    @classmethod
    def test(cls):
        MailToMacro.test()
        DivMacro.test()
        IncludeMacro.test()
        TOCMacro.test()
        BRMacro.test()
        parse("<<div>>", cls)
        parse("<<div(center)>>", cls)
        parse("<<div(indent)>>", cls)
        parse("<<Include(FrontPage/Use Galaxy)>>", cls)
        parse("<<Include(Develop/LinkBox)>>", cls)
        parse(r'<<Include(/Includes, , from="= LA T =\n", to="\nEN_CL")>>', cls)



    
# ===============
# Section Header
# ===============

class SectionHeader(List):
    """
    Section headers start and end with = signs.  The more signs the smaller the header
      = Top level Header =
      == 2nd level Header ==

    That must be the only thing on the line.  Moin does not like leading or
    trailing spaces.
    """        
    grammar = contiguous(
        attr("depth", re.compile(r"^=+")),
        re.compile(" +"),
        attr("name", re.compile(r".+(?= +=+)")),
        re.compile(r" +=+\n"))

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.

        How can that be dangerous?
        """
        return("#" * len(self.depth) + " " + self.name + "\n")        

        

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        return()
        parse("= A single tool or a suite of tools per repository =\n ", cls)
        parse("= Heading 1 =\n", cls)
        parse("== Heading Too! ==\n", cls)


        
# =============
# Links
# =============


class LinkProtocol(List):
    """
    http, ftp etc.
    """
    grammar = contiguous(
        attr("protocol", re.compile(r"((http)|(https)|(ftp))\://",
                                    re.IGNORECASE)))

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return(self.protocol)
    
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("http://", cls)
        parse("ftp://", cls)
        parse("https://", cls)

    
class ExternalLink(List):
    """
    Links that go outside the wiki.
    """
    grammar = contiguous(
        "[[",
        attr("protocol", LinkProtocol),
        attr("path", ExternalPagePath),
        optional("|", attr("linkText", re.compile(r".+?(?=\]\])"))),
        "]]")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        linkOut = compose(self.protocol) + compose(self.path)
        # Try with link text first
        try:
            out = "[" + self.linkText + "](" + linkOut + ")"
        except AttributeError:
            # err on the safe side
            out = "[" + linkOut + "](" + linkOut + ")" 
        return(out)


    def composeHtml(self):
        linkOut = compose(self.protocol) + compose(self.path)
        # Try with link text first
        try:
            out = "<a href='" + linkOut + "'>" + self.linkText + "</a>"
        except AttributeError:
            # err on the safe side
            out = "<a href='" + linkOut + "'>" + linkOut + "</a>"
        return(out)


        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        LinkProtocol.test()
        parse("[[http://link.com]]", cls)
        parse("[[ftp://this.here.com/path/file.txt]]", cls)
        parse("[[https://link.com/]]", cls)
        parse("[[http://link.com|Linkin somewhere]]", cls)
        parse("[[ftp://this.here.com/path/file.txt|Text for link.]]", cls)
        parse("[[https://link.com/| Whitespace test ]]", cls)



class InternalLink(List):
    """
    Links that go inside the wiki.

    GFM inverts the syntax of relative and root-derived links, compared to
    MoinMoin.
    In Moin relative links start with "/"
    In GFM relative linking is assumed, and starting a link with "/" may be
    undefined.

    So, this calls for some knowledge of the path to the current page in
    the MoinMoin directory, and the home of th enew page in the Markdown
    directory, to correctly translate.
    TODO
    """
    grammar = contiguous(
        "[[",
        maybe_some(whitespace),
        attr("path", InternalPagePath),
        optional("|", attr("linkText", re.compile(r".+?(?=\]\])"))),
        "]]")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        # Try with link text first
        try:
            out = "[" + self.linkText + "](" + compose(self.path) + ")"
        except AttributeError:
            # err on the safe side
            out = "[" + compose(self.path) + "](" + compose(self.path) + ")" 
        return(out)


    def composeHtml(self):
        # Try with link text first
        try:
            out = "<a href='" + compose(self.path) + "'>" + self.linkText + "</a>"
        except AttributeError:
            # err on the safe side
            out = ("<a href='" + compose(self.path) + "'>" +
                   compose(self.path) + "</a>")
        return(out)



        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("[[/PathToPage]]", cls)
        parse("[[path/file.txt]]", cls)
        parse("[[path/more/path/Page Name]]", cls)
        parse("[[/PathToPage|With Text]]", cls)
        parse("[[path/file.txt|uh-huh!]]", cls)
        parse("[[path/more/path/Page Name|Whitespace test 1]]", cls)
        parse("[[path/more/path/Page Name| Whitespace test 2 ]]", cls)



class ImageLink(List):
    """
    Link that shows an image, rather than text.

    In MoinMoin these look like:
      [[http://address.com|{{attachment:Images/Search.png|Search|width="120"}}]]

    So, it's the 2nd part of the link that tells us this is an image.
      
    See http://stackoverflow.com/questions/30242558/how-do-you-create-a-relative-image-link-w-github-flavored-markdown
    for this Markdown solution:
      [[[/images/gravatar.jpeg]]](http://www.inf.ufrgs.br) 

    Many image links include sizing, and that is not supported in Markdown.
    May just be better to go straight to HTML?
    """
    grammar = contiguous(
        "[[",
        [(attr("protocol", LinkProtocol), attr("linkPath", ExternalPagePath)),
         attr("linkPath", InternalPagePath)],
        "|{{attachment:",
        [(attr("imageProtocol", LinkProtocol), attr("imagePath", ExternalPagePath)),
         attr("imagePath", InternalPagePath)],
        optional(
            "|",
            optional(attr("altText", re.compile(r"[^}|]*"))),
            optional(
                "|",
                attr("imageSize", re.compile(r"[^\}]*")))),
        "}}",
        "]]")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        # Generate HTML img link as it can deal with alt txt and sizes
        out = "<a href='"
        try:
            out += compose(self.protocol)
        except AttributeError:
            pass
        
        out += self.linkPath + "'>"
        out += "<img src='" + compose(self.imagePath) + "'"
        
        # Add alt text
        try:
            out += " alt='" + self.altText + "'" + compose(self.link) + ")"
        except AttributeError:
            pass
        # other stuff at the end
        try:
            out += " " + self.imageSize
        except AttributeError:
            pass
        out += " /></a>"
                    
        return(out)

        
    def composeHtml(self):
        """
        Same markup is generated for Markdown and HTML cases.
        """
        return(compose(self))

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse('[[search/getgalaxy|{{attachment:GetGalaxySearch.png}}]]', cls)
        parse('[[http://gp.org/sch/getxy|{{attachment:Im/L/GGS.png|S all}}]]',
              cls)
        parse('[[http://gt.g/gy|{{attachment:Is/L/G.png|s a|width="120"}}]]',
              cls)
        parse('[[http://workflow4metabolomics.org/training/W4Mcourse2015|{{attachment:Images/Logos/w4m_logo_small.png|Traitement des données métabolomiques sous Galaxy|height="80"}}]]', cls)
        parse('[[http://wacd.abrf.org/|{{attachment:Images/Logos/WACD.png|Western Association of Core Directors (WACD) Annual Meeting|height="70"}}]]', cls)

        
       

class Link(List):
    """
    Links in Moin are enclosed in [[ ]].  Some have text, some have embedded
    images, and some have extra params.
    """
    grammar = contiguous(
        attr("link", [ImageLink, ExternalLink, InternalLink]))

        
    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return(compose(self.link))


    def composeHtml(self):
        """
        For cases when the subelement needs to be rendered in HTML (such as
        inside a table).
        """
        return(self.link.composeHtml())

        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        ExternalLink.test()
        InternalLink.test()
        ImageLink.test()
        parse("[[https://developers.google.com/open-source/soc|Google Summer of Code 2015]]", cls)
        parse(" [[http://link.com|Link to here]]", cls)
        parse("[[LinkToPage]]", cls)
        parse("[[LinktoPage|Text shown for link]]", cls)
        parse("[[https://developers.google.com/+/features/sign-in|Google+ sign-in]]", cls)
        parse("[[http://www.citeulike.org/group/16008/order/to_read,desc,|Galaxy papers on CituLike]]", cls)
        parse("[[http://bioblend.readthedocs.org/en/latest/|bioblend]]", cls)

# =============
# Subelements
# =============

class Subelement(List):
    """
    Subelements can occur in paragraphs or table text.

    Subelements can also be elements.
    """
    grammar = contiguous(
        [Macro, Link, Bold, Italic, Monospace,
         FontSizeChangeStart, FontSizeChangeEnd,
         InlineComment, PlainText, Punctuation])

    
    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        out = ""
        for item in self:
            out += compose(item)
        return(out)


    def composeHtml(self):
        """
        For cases when the subelement needs to be rendered in HTML (such as
        inside a table).
        """
        out = ""
        for item in self:
            out += item.composeHtml()
        return(out)
        

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        Link.test()
        Macro.test()
        PlainText.test()
        Bold.test()
        Italic.test()
        Monospace.test()
        FontSizeChangeStart.test()
        FontSizeChangeEnd.test()
        InlineComment.test()
        Punctuation.test()


# ===========
# Lists
# ===========

class BulletListItem(List):
    """
    An individual entry in a bullet list.

    Look like
     * Text here.

    But, can't get pypeg's whitespace to work, so grammar drops spaces.
    That's a problem as we need to know depth.
    """
    grammar = contiguous(
        attr("depth", re.compile(r" *")),
        attr("bullet", re.compile(r"\*")),
        re.compile(r" +"),
        attr("item", some(Subelement)),
        re.compile(r" *"),
        "\n"
        )


    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        out = "* "
        for subelement in self.item:
            out += compose(subelement)
        out += "\n"
        return(out)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse(" * E\n", cls)
        parse(" * Electric boogaloo\n", cls)
        parse(" * A simple case.\n", cls)
        parse(" * A simple case \n", cls)


class BulletList(List):
    """
    Look like
     * Text goes here
     * More text here
    """
    grammar = contiguous(some(BulletListItem))

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        out = ""
        for item in self:
            out += compose(item)
        return(out)
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        BulletListItem.test()
        parse(" * One Item Only\n", cls)
        parse(" * A simple case.\n * With two items\n", cls)
        parse(""" * A simple case.
   * With nested item
""", cls)
        parse(""" * A simpler case.
   * With nested item
   * and another
""", cls)
        parse(""" * A less simplerer case.
   * With nested item
   * And another
     * and More!
   * Uh huh.
""", cls)



class NumberedListItem(List):
    """
    An individual entry in a numbered list.

    Look like
     1. Text here.
     1. More Here.
    or
     1. Item 1
     2. Item 2
    """
    grammar = contiguous(
        attr("depth", re.compile(r" *")),
        attr("number", re.compile(r"\d+\.")),
        re.compile(r" +"),
        attr("item", some(Subelement)),
        re.compile(r" *"),
        "\n"
        )


    def compose(self, parser, attr_of):
        out = "1. "
        for subelement in self.item:
            out += compose(subelement)
        out += "\n"
        return(out)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse(" 1. E\n", cls)
        parse(" 2. Electric boogaloo\n", cls)
        parse(" 11. A simple case.\n", cls)
        parse(" 12. A simple case \n", cls)


class NumberedList(List):
    """
    Look like
     1. Text goes here
     1. More text here

    TODO: Deal with depth.
    """
    grammar = contiguous(some(NumberedListItem))

    def compose(self, parser, attr_of):
        out = ""
        for item in self:
            out += compose(item)
        return(out)
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        BulletListItem.test()
        parse(" 1. One Item Only\n", cls)
        parse(" 2. A simple case.\n 3. With two items\n", cls)
        parse(""" 22. A simple case.
   24. With nested item
""", cls)
        parse(""" 17. A simpler case.
   1. With nested item
   1. and another
""", cls)
        parse(""" 1. A less simplerer case.
   1. With nested item
   1. And another
     1. and More!
   1. Uh huh.
""", cls)




# ===========
# Tables - EEK!
# ===========


class CellMoinFormatItem(List):
    """
    Moin uses special characters to modify cell format.  This captures any
    one of them.

    These include
      -2    colspan
      |2    rowspan
      50%   cell width        - have no idea if we use this.
      width="50%" cell width  ~ about 20 pages
      (           left aligned (will append text-align: left; to style)
      :           centered
      )           right aligned (will append text-align: right; to style)
      ^           aligned to top (will append vertical-align: top; to style)
      v           aligned to bottom (will append vertical-align: bottom; to style)
      style="border: none"
      bgcolor="#XXXXXX"          - used in 10 places

    Not used in Galaxy Wiki:
      tablewidth="100%"
      #XXXXXX     background color  - don't think this is used
      rowbgcolor="#XXXXXX" set row background color (only valid in first cell)
      tablebgcolor="#XXXXXX" set table background color
    """
    grammar = contiguous(
        [("-", attr("colspan", re.compile(r"\d+"))),
         ("|", attr("rowspan", re.compile(r"\d+"))),
         attr("left", "("),
         attr("right", ")"),
         attr("center", ":"),
         attr("top", "^"),
         attr("bottom", "v"),
         ("style=", attr("cellStyle", QuotedString)),
         ("bgcolor=", attr("bgcolor", QuotedString)), 
         [
             (optional("width="), attr("width", QuotedString)),
             (attr("width", re.compile(r"\d+(%|em|ex|px|cm|mm|in|pt|pc)")))]
        ])

    def compose(self, parser, attr_of):
        """
        Ignore CellMoinFormatItems for the time being.
        TODO
        """
        if hasattr(self, "colspan"):
            return("COLSPAN=" + self.colspan)
        elif hasattr(self, "rowspan"):
            return("ROWSPAN=" + self.rowspan)
        elif hasattr(self, "left"):
            return("LEFT")
        elif hasattr(self, "right"):
            return("RIGHT")
        elif hasattr(self, "center"):
            return("CENTER")
        elif hasattr(self, "top"):
            return("TOP")
        elif hasattr(self, "bottom"):
            return("BOTTOM")
        elif hasattr(self, "cellStyle"):
            return("STYLE=" + compose(self.cellStyle))
        elif hasattr(self, "bgcolor"):
            return("BGCOLOR=" + compose(self.bgcolor))
        elif hasattr(self, "width"):
            return("WIDTH=" + compose(self.width))
        return("UNRECOGNOZED CELL FORMAT ITEM")

    def composeHtml(self):
        """
        render CellMoinFormatItems as HTML.

        Returns
        1) a string with the format item in HTML, and
        2) True if it's a style attirbute, and false if it's standalone
        
        Assumes you are inside a td or th already.
        """
        if hasattr(self, "colspan"):
            return("colspan=" + self.colspan, False)
        elif hasattr(self, "rowspan"):
            return("rowspan=" + self.rowspan, False)
        elif hasattr(self, "left"):
            return('text-align: left;', True)
        elif hasattr(self, "right"):
            return('text-align: right;', True)
        elif hasattr(self, "center"):
            return('text-align: center;', True)
        elif hasattr(self, "top"):
            return("vertical-align: top;", True)
        elif hasattr(self, "bottom"):
            return("vertical-align: bottom;", True)
        elif hasattr(self, "cellStyle"):
            return(self.cellStyle.justTheString(), True)
        elif hasattr(self, "bgcolor"):
            return("background-color: " + self.bgcolor.justTheString() + ";",
                   True)
        elif hasattr(self, "width"):
            return("width: " + self.width.justTheString() + ";", True)
        return("UNRECOGNOZED CELL FORMAT ITEM for HTML")


    
    @classmethod
    def test(cls):
        parse("|7", cls)
        parse("-5", cls)
        
        parse("(", cls)
        parse(")", cls)
        parse(":", cls)
        parse("^", cls)
        parse("v", cls)
        parse('style="border: none"', cls)
        parse('style="border: none;"', cls)
        parse('style="border: none; width: 20%"', cls)
        parse('style="border: none; width: 20%;"', cls)
        parse('bgcolor="#fffddd"', cls)
        parse('width="20%"', cls)
        parse("20%", cls)

        
class CellClass(List):
    grammar = contiguous(
        "class=", attr("cellClass", QuotedString))     

    def compose(self, parser, attr_of):
        return("CLASS=" + compose(self.cellClass))

    def isHeader(self):
        return(self.cellClass.justTheString().lower() == "th")

        
    @classmethod
    def test(cls):
        parse('class="th"', cls)
        parse('class="not-th"', cls)


class TableCell(List):
    grammar = contiguous(
        optional(
            "<",
            some([attr("cellClass", CellClass),
                  attr("cellFormat", some([CellMoinFormatItem, omit(" ")]))]),
            ">"),
        maybe_some(" "),
        attr("cellContent", maybe_some(Subelement)), 
        maybe_some(" "),
        "||")

    def compose(self, parser, attr_of):
        """
        Compose a cell.

        It's up to the table/tablerow to make sure the leading || is already
        in place.  Each cell is responsible for its trailing ||.
        """

        # start simple; TODO
        try:
            out = ""
            for item in self.cellFormat:
                out += compose(item)
        except AttributeError:
            out = ""

        try:
            for item in self.cellContent:
                out += compose(item)
        except AttributeError:
            pass
        return(out + " |")

     
    @classmethod
    def test(cls):
        CellClass.test()
        CellMoinFormatItem.test()
        Subelement.test()
        
        parse('<-3> ||', cls)
        parse('< style="background-color: #eef"> ||', cls)
        parse('<-3 style="background-color: #eef"> ||', cls)

        parse('Topic||', cls)
        parse('<|5 -2> Topic/Event ||', cls)
        parse(" ||", cls)
        parse("<|5> Text ||", cls)
        parse("<|2> Electric boogaloo ||", cls)
        parse(" Electric boogaloo ||", cls)
        parse(' Topic/Event ||', cls)


class RowStyle(List):
    grammar = contiguous(
        "rowstyle=", attr("rowStyle", QuotedString))     

    def compose(self, parser, attr_of):
        return("ROWSTYLE=" + compose(self.rowStyle))

    @classmethod
    def test(cls):
        parse('rowstyle="border: none"', cls)    
        parse('rowstyle="border: none;"', cls)
        parse('rowstyle="border: none; width: 300px"', cls)
        parse('rowstyle="border: none; width: 300px;"', cls)



class RowClass(List):
    grammar = contiguous(
        "rowclass=", attr("rowClass", QuotedString))

    def compose(self, parser, attr_of):
        return("ROWCLASS=" + compose(self.rowClass))

    def isHeader(self):
        return(self.rowClass.justTheString().lower() == "th")


        
    @classmethod
    def test(cls):
        parse('rowclass="th"', cls)
        parse('rowclass="spangled"', cls)

        
class TableRow(List):
    """
    An individual table row

    Look like
    ||<rowclass="th" width="7em">Date ||Topic/Event ||Venue/Location ||Contact ||
    """
    
    grammar = contiguous(
        "||",
        optional(
            "<",
            some([attr("rowStyle", RowStyle),
                  attr("rowClass", RowClass),
                  attr("firstCellClass", CellClass),
                  attr("firstCellFormat", some([CellMoinFormatItem, omit(" ")])),
                  " "]),
            ">"),
        maybe_some(" "),
        attr("firstCellContent", maybe_some(Subelement)),
        maybe_some(" "),
        "||",
        attr("rowCells", maybe_some(TableCell)),
        "\n"
        )
    def compose(self, parser, attr_of):
        """
        Generate a table row in Markdown.
    
        This is only invoked where the table can be generated using Markdown.
        """
        firstCellText = "| "
        for item in self.firstCellContent:
            firstCellText += compose(item)
        out = firstCellText + "| "
        if self.rowIsHeader():
            headerOut = "| " + "-" * (len(firstCellText)-3) + " | "

        for cell in self.rowCells:
            cellText = " "
            for item in cell.cellContent:
                cellText += compose(item)
            out += cellText + " | "
            if self.rowIsHeader():
                headerOut += "-" * (len(cellText)-1) + " | "
        
        out += "\n"
        if self.rowIsHeader():
            out += headerOut + "\n"
            
        return(out)

    def rowIsHeader(self):
        """
        Return true if every cell in the row is a header cell.
        """
        # Check whole row first
        if hasattr(self, "rowClass") and self.rowClass.isHeader():
            return(True)                   # is header at row level.
            
        elif hasattr(self, "firstCellClass") and self.firstCellClass.isHeader():
            # or, every cell might be indivudaully specified as th.
            for cell in self.rowCells:
                if hasattr(cell, "cellClass") and cell.cellClass.isHeader():
                    pass                  # is header so far.
                else:
                    return(False)

            return(True)                  # is header in every cell


    def getRowClass(self):
        """
        Return the class of the row, if one exists, as a quoted string,
        or None if not.
        """
        if hasattr(self, "rowClass"):
            return(compose(self.rowClass))
        return None
        
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        RowStyle.test()
        RowClass.test()
        CellClass.test()
        CellMoinFormatItem.test()
        Subelement.test()
        TableCell.test()
        parse('||<class="th"> ||<-3 style="background-color: #eef"> ||\n', cls)
        parse('||<rowclass="th"> Date||\n', cls)
        parse('||<rowclass="th" width="7em">Date ||Topic/Event ||Venue/Location ||Contact ||\n', cls)
        parse('|| a ||\n', cls)
        parse('||<|2> ||\n', cls)
        parse('||<|7 rowclass="th"> ||\n', cls)
        parse("||<|5> Text ||\n", cls)
        parse("|| Electric boogaloo||\n", cls)
        parse("""|| <<MailTo( w4mcourse2015.organisation@sb-roscoff.fr, W4M Course Organisers)>> ||\n""", cls)
        parse("""|| ||<<div(right)>>[[http://bit.ly/gxytrnGUGGO|{{attachment:Images/GalaxyLogos/GTN16.png|Training offered by GTN Member}}]]<<div>> <<MailTo( w4mcourse2015.organisation@sb-roscoff.fr, W4M Course Organisers)>> ||\n""", cls)
        parse("""||<class="th"> September 21-25 || || <<MailTo( w4mcourse2015.organisation@sb-roscoff.fr, W4M Course Organisers)>> ||\n""", cls)
        parse("""||<class="th"> September 21-25 || ''[[http://workflow4metabolomics.org/training/W4Mcourse2015|Traitement des données métabolomiques sous Galaxy]]'' ||<<Include(Events/Badges/Europe)>> Station Biologique de Roscoff, France ||<<div(right)>>[[http://bit.ly/gxytrnGUGGO|{{attachment:Images/GalaxyLogos/GTN16.png|Training offered by GTN Member}}]]<<div>> <<MailTo( w4mcourse2015.organisation@sb-roscoff.fr, W4M Course Organisers)>> ||\n""", cls)
        parse("""||<class="th"> September 28 || ''[[http://www.emgs-us.org/AM2015/agendamon.asp|Mutational Analysis with Random DNA Identifiers (MARDI), a High-Fidelity NGS Approach That Simultaneously Identifies Gene Marker Mutations from Heterogeneous Mutant Cell Populations]]'' ||<<Include(Events/Badges/NorthAmerica)>> [[http://www.emgs-us.org/AM2015/index.asp|Environmental Mutagenesis and Genomics Society (EMGS)]], New Orleans, Louisiana, United States || Javier Revollo ||\n""", cls)
        parse("""||<class="th"> September 21-23 || [[https://www.regonline.com/builder/site/Default.aspx?EventID=1692764|JHU-DaSH: Data Science Hackathon]] ||<<Include(Events/Badges/NorthAmerica)>> [[https://www.regonline.com/builder/site/tab2.aspx?EventID=1692764|Baltimore]], Maryland, United States || <<MailTo(jhuDaSH@jhu.edu, Email)>> ||\n""", cls)



        
class Table(List):
    """
    There is no explicit table start or end text in MoinMoin.  A table starts
    with the first row, and then goes until there is no more rows.

    The first cell of the first row is also special, but only because only the
    first row can be special in GFM.
    """
    grammar = contiguous(attr("tableRows", some(TableRow)))

    def compose(self, parser, attr_of):

        # Can this table be rendered in GFM, or does it need HTML?
        if self.needsHTMLRendering():
            out = self.composeHtml()
        else:
            out = ""
            for row in self.tableRows:
                out += compose(row)
            
        return(out)

    def needsHTMLRendering(self):
        """
        Answers the question: does this table need to be rendered in HTML?

        What can be rendered in GFM:
         - same number of cells in every row (no rowspans or colspans)
         - must have a header row
         - Cells without any markdown
        If the table meets all those criteria it can be rendered in GFM.
         
        Q: Why not just render everying in HTML?  The whole point of a wiki
        is to make it easy to edit.  GFM table notation is way easier than
        HTML.
        """

        # Walk though each row looking for markup we can't deal with        
        rowIdx = 0
        firstRowIsHeader = False
        for row in self.tableRows:
            if hasattr(row, "rowClass"):
                # if first row is not a header, or if a row other than
                # the first one has a class then it must be rendered in HTML
                if row.rowIsHeader() and rowIdx == 0:
                    firstRowIsHeader = True
                else:
                    return True           # needs to be in HTML

            if hasattr(row, "rowStyle") or hasattr(row, "firstCellFormat"):
                return(True)              # no styling supported in GFM

            # Only styling permitted from here on (for GFM) is all cells in
            # first row can be header cells.
            if hasattr(row, "firstCellClass"):
                if rowIdx > 0 or not row.firstCellClass.isHeader():
                    return(True)          # Sorry, not header

            for cell in row.rowCells:
                if hasattr(cell, "cellClass"):
                    if rowIdx > 0 or not cell.cellClass.isHeader():
                        return(True) 
                if hasattr(cell, "cellStyle"):
                    return(True)          # no style supported anywhere
            
            rowIdx += 1

        if firstRowIsHeader:
            return(False)

        return(True)                     # Does not require HTML


    def composeCellHtml(self, row, cellClass, cellFormat, cellContent):
        """
        compose a cell in HTML.

        If is HTML then all markup in it must be in HTML too.
        
        This routine exists here (rather than as a method of TableCell because
        the first cell of a row is problematic.
        """
        
        # render first cell
        cellType = "td"
        cellStyle = ""
        cellAttribs = ""

        if row.rowIsHeader() or (cellClass != None and cellClass.isHeader()):
            cellType = "th"
        if cellClass != None and not cellClass.isHeader():
            cellStyle += " class=" + cellClass.quotedText + " "
        if cellFormat != None:
            for formatItem in cellFormat:
                formatText, inStyle = formatItem.composeHtml()
                if inStyle:
                    cellStyle += " " + formatText
                else:
                    cellAttribs += " " + formatText

        if cellStyle:
            cellStyle = ' style="' + cellStyle + '"'

        cellContentText = ""
        for item in cellContent:
            cellContentText += item.composeHtml()
        cellHtml = (
            "    <" + cellType + cellAttribs + cellStyle + "> " +
            cellContentText + "</" + cellType + ">\n")
        return(cellHtml)


                
    def composeHtml(self):
        """
        Table contains markup that cannot be rendered in GFM.
        """
        out = "<table>\n"

        for row in self.tableRows:
            # generate the row header
            rowHtml = "  <tr"
            if hasattr(row, "rowClass"):
                rowHtml += " class=" + row.rowClass.rowClass.quotedText + " "
            if hasattr(row, "rowStyle"):
                rowHtml += " style=" + row.rowStyle.rowStyle.quotedText + " "
            rowHtml += ">\n"
            out += rowHtml
            
            # render first cell
            cellClass = None
            if hasattr(row, "firstCellClass"):
                cellClass = row.firstCellClass
            cellFormat = None
            if hasattr(row, "firstCellFormat"):
                cellFormat = row.firstCellFormat
            out += self.composeCellHtml(row, cellClass, cellFormat,
                                        row.firstCellContent)
            
            # render the rest of the cells
            for cell in row.rowCells:
                cellClass = None
                if hasattr(cell, "cellClass"):
                    cellClass = cell.cellClass
                cellFormat = None
                if hasattr(cell, "cellFormat"):
                    cellFormat = cell.cellFormat
                out += self.composeCellHtml(row, cellClass, cellFormat,
                                            cell.cellContent)

            # Render the end of the row
            out += "  </tr>\n"

        # render the end of the table
        out += "</table>\n\n"

        return(out)



    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        TableRow.test()
        parse('||<rowclass="th"> Date ||\n', cls)

        parse('||<rowclass="th" width="7em">Date ||\n', cls)

        parse('||<rowclass="th" width="7em">Date ||Topic/Event ||Venue/Location ||Contact ||\n||<class="th"> September 14-18 || ''[[http://training.bioinformatics.ucdavis.edu/2015/01/13/using-galaxy-for-analysis-of-high-throughput-sequence-data-september-14-18-2015/|Using Galaxy for Analysis of High Throughput Sequence Data]]'' ||<<Include(Events/Badges/NorthAmerica)>> [[http://bioinformatics.ucdavis.edu/|UC Davis Bioinformatics Core]], Davis, California, United States ||<<div(right)>>[[http://bit.ly/gxytrnUCDavis|{{attachment:Images/GalaxyLogos/GTN16.png|Training offered by GTN Member}}]]<<div>>  ||\n', cls)
        
        parse("""||<class="th"> September 21-23 || [[https://www.regonline.com/builder/site/Default.aspx?EventID=1692764|JHU-DaSH: Data Science Hackathon]] ||<<Include(Events/Badges/NorthAmerica)>> [[https://www.regonline.com/builder/site/tab2.aspx?EventID=1692764|Baltimore]], Maryland, United States || <<MailTo(jhuDaSH@jhu.edu, Email)>> ||
||<class="th"> September 21-25 || ''[[http://workflow4metabolomics.org/training/W4Mcourse2015|Traitement des données métabolomiques sous Galaxy]]'' ||<<Include(Events/Badges/Europe)>> Station Biologique de Roscoff, France ||<<div(right)>>[[http://bit.ly/gxytrnGUGGO|{{attachment:Images/GalaxyLogos/GTN16.png|Training offered by GTN Member}}]]<<div>> <<MailTo( w4mcourse2015.organisation@sb-roscoff.fr, W4M Course Organisers)>> ||
||<class="th"> September 28 || ''[[http://www.emgs-us.org/AM2015/agendamon.asp|Mutational Analysis with Random DNA Identifiers (MARDI), a High-Fidelity NGS Approach That Simultaneously Identifies Gene Marker Mutations from Heterogeneous Mutant Cell Populations]]'' ||<<Include(Events/Badges/NorthAmerica)>> [[http://www.emgs-us.org/AM2015/index.asp|Environmental Mutagenesis and Genomics Society (EMGS)]], New Orleans, Louisiana, United States || Javier Revollo ||\n""", cls)        
        parse("""||<class="th"> September 17-18 || '''[[News/ToolsCollectionsHack|Remote Hackathon for Tools and Dataset Collections]]''' || <<Include(Events/Badges/World)>> ''Online'' || <<MailTo(galaxy-iuc@lists.galaxyproject.org, IUC)>> ||
||<class="th"> September 17-18 || ''Utilizing the Galaxy Analysis Framework at Core Facilities'' || <<Include(Events/Badges/NorthAmerica)>> [[http://wacd.abrf.org/|Western Association of Core Directors (WACD) Annual Meeting]], Portland, Oregon, United States || [[DaveClements|Dave Clements]] ||
||<class="th"> September 21-23 || [[https://www.regonline.com/builder/site/Default.aspx?EventID=1692764|JHU-DaSH: Data Science Hackathon]] ||<<Include(Events/Badges/NorthAmerica)>> [[https://www.regonline.com/builder/site/tab2.aspx?EventID=1692764|Baltimore]], Maryland, United States || <<MailTo(jhuDaSH@jhu.edu, Email)>> ||
||<class="th"> September 21-25 || ''[[http://workflow4metabolomics.org/training/W4Mcourse2015|Traitement des données métabolomiques sous Galaxy]]'' ||<<Include(Events/Badges/Europe)>> Station Biologique de Roscoff, France ||<<div(right)>>[[http://bit.ly/gxytrnGUGGO|{{attachment:Images/GalaxyLogos/GTN16.png|Training offered by GTN Member}}]]<<div>> <<MailTo( w4mcourse2015.organisation@sb-roscoff.fr, W4M Course Organisers)>> ||
||<class="th"> September 28 || ''[[http://www.emgs-us.org/AM2015/agendamon.asp|Mutational Analysis with Random DNA Identifiers (MARDI), a High-Fidelity NGS Approach That Simultaneously Identifies Gene Marker Mutations from Heterogeneous Mutant Cell Populations]]'' ||<<Include(Events/Badges/NorthAmerica)>> [[http://www.emgs-us.org/AM2015/index.asp|Environmental Mutagenesis and Genomics Society (EMGS)]], New Orleans, Louisiana, United States || Javier Revollo ||
||<class="th"> September 28-30 || ''[[http://biosb.nl/events/course-next-generation-sequencing-ngs-data-analysis-2015/|Next generation sequencing (NGS) data analysis]]'' ||<<Include(Events/Badges/Europe)>> [[http://www.medgencentre.nl/|University Medical Centre Groningen]], The Netherlands ||<<Include(Teach/GTN/Badge16)>>  <<MailTo(education@biosb.nl, BioSB Education)>> ||
""", cls)
        

# ================
# Paragraph
# ================

class Paragraph(List):
    """
    Paragraphs are text separated by blank lines or other tokens.
    """
    grammar = contiguous(some(Subelement))

    def compose(self, parser, attr_of):
        out = ""
        for item in self:
            out += compose(item)
        return(out)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("""Let's try plain text first.
        
        """, cls)



# ================
# Elements
# ===============
    
class Element(List):
    """
    An element is anything that can stand on it's own, at the the highest level
    of the Document.

    Elements don't have to be at the top level, but they can be.
    """
    grammar = contiguous(
        [SectionHeader, BulletList, NumberedList, Table, Macro,
         CodeBlockStart, CodeBlockEnd, FontSizeChangeStart, FontSizeChangeEnd,
         Comment, Paragraph, TrailingWhitespace])


    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return(compose(self[0]))

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        Table.test()
        SectionHeader.test()
        BulletList.test()
        NumberedList.test()
        Macro.test()
        CodeBlockStart.test()
        CodeBlockEnd.test()
        Comment.test()
        Paragraph.test()
        #TrailingWhitespace.test()
            

# =================
# Processing Instructions
# =================


class FormatPI(List):
    grammar = contiguous(
        "#format ",
        attr("format", re.compile(r"[\w/]+")))

    def compose(self, parser, attr_of):
        if self.format == "wiki":
            return("")
        else:
            raise NotImplementedError(self.format + " parsing is not supported.")

#    @classmethod
#    def parse(cls, parser, text, pos):
#        print("YES", text, pos)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("#format wiki", cls)
        parse("#format text/creole", cls)
        

class RedirectPI(List):
    """
    Not sure what to do with redirects.

    Probably want to have a clean slate as far as redirects go.  Which
    means don't do anything with them.
    """
    grammar = contiguous(
        re.compile(r"#REDIRECT ", re.IGNORECASE),
        attr("redirect", InternalPagePath))

    def compose(self, parser, attr_of):
        raise NotImplementedError("Not generating REDIRECT Pages. Letting them die.")

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("#REDIRECT CloudMan/AWS/AMIs\n", cls)
        parse("#REDIRECT Learn/IntervalOperations", cls)
        parse("#redirect Events/Meetups/Baltimore/20150122", cls)
        parse("#redirect Events/Meetups/Baltimore/2015-01-22", cls)
        parse("#redirect Events/Meetups/Baltimore/2015-01-22\n", cls)
        parse("#redirect Events/Meetups/Baltimore/2015-01-22 \n", cls)

class RefreshPI(List):
    """
    The refresh is effectively a redirect to an external page.

    We aren't propoagating redirects, don't propagate refreshes either.
    """
    grammar = contiguous(
        re.compile(r"#refresh "),
        attr("redirect", restline))

    def compose(self, parser, attr_of):
        raise NotImplementedError("Not generating refresh Pages. Letting them die.")

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("#refresh http:/a.b.c/CloudMan/AWS/AMIs\n", cls)
        parse("#refresh https://Learn/IntervalOperations#fish", cls)

class PragmaPI(List):
    """
    Pragma is used to control some behavious.  The only one we have is

      #pragma section-numbers off    

    I'm going to make an executive decision that we don't care about these
    """
    grammar = contiguous(
        re.compile(r"#pragma "),
        attr("pragma", restline))

    def compose(self, parser, attr_of):
        return("")

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("#pragma section-numbers off", cls)

        
class ProcessingInstruction(List):
    """
    Happen at top of file.

    Have the form
     #format        - lots 
     #redirect      - lots
     #refresh       - have one of these
     #pragma        - have 2 both are
       #pragma section-numbers off
     #deprecated    - have 0
     #language      - have 51 of these, all en

    Comments, which start with ## are handled elsewhwere.
    """
    grammar = contiguous(
        attr("pi", [FormatPI, RedirectPI, RefreshPI, PragmaPI]))

    
#        attr("pi",[FormatPI, RedirectPI, RefreshPI, PragmaPI, LanguagePI]),

    
    def compose(self, parser, attr_of):
        return(compose(self.pi))
    
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        FormatPI.test()
        #RedirectPI.test()
        #RefreshPI.test()
        PragmaPI.test()
        parse("#format wiki\n", cls)
        parse("#format text/creole\n", cls)
        
        
class Document(List):
    """
    Parse the whole page.

    Moin pages don't have to contain anything, and most items do not have to be in a
    particular order.

    Does the page arrive as a list of text lines?
    """
    grammar = contiguous(
        maybe_some([ProcessingInstruction, Comment]),
        maybe_some(Element))


    @classmethod
    def test(cls):
        parse("""#REDIRECT CloudMan/AWS/AMIs
""", cls)



# =================================
# Non grammar subs
# =================================

class Argghhs(object):
    """
    Process and provide access to command line arguments.
    """

    def __init__(self):
        argParser = argparse.ArgumentParser(
            description="Convert a single wiki page (a file) from MoinMoin to Github Flavored Markdown. Running this with no params does nothing.  Running with --debug produces a LOT of output. Markdown is sent to stdout.",
            epilog="Example: " + os.path.basename(__file__) +
            " --moinpage=Admin.moin --debug")
        argParser.add_argument(
            "--moinpage", required=False, default=None,
            help="File containing a single MoinMoin page.")
        argParser.add_argument(
            "--runtests", required=False, 
            help="Run Unit Tests.",
            action="store_true")
        argParser.add_argument(
            "--debug", required=False, 
            help="Include debug output",
            action="store_true")
        self.args = argParser.parse_args()

        return(None)


def testFail(testText, cls):
    """
    Run a parse test that should fail.
    """
    try:
        parsed = parse(testText, cls)
        print(parsed)
        print("ERROR: Test that should have failed did not fail.")
        print("Test:")
        print(testText)
        printList(parsed)
        raise BaseException(cls.__name__)
    except (SyntaxError, TypeError):
        pass                              # TypeError is b/c of pypeg bug.
    return()


def printList(list, indent=0):
    for item in list:
        print("." * indent, item)
        if item != None and not isinstance(item, str):
            print("c" * indent, compose(item))
            printList(item, indent+2)
        else:
            print("n" * indent, "None")
    try:
        for name, item in list.__dict__.items():
            if name not in ["position_in_text"]:
                print("d" * indent, name, ":", item)
                if item != None and not isinstance(item, str):
                    if len(item) > 0:
                        print("c" * indent, name, ":", compose(item))
                        printList(item, indent+2)
                else:
                    print("n" * indent, name, ": None")
    except AttributeError:
        pass               # Classes that don't name any attr's have no dict

def runTests():
    global args

    CellMoinFormatItem.test()
    CellClass.test()
    TableCell.test()
    RowStyle.test()
    RowClass.test()
    TableRow.test()
    Table.test()
    
    ProcessingInstruction.test()
    BulletList.test()
    SectionHeader.test()
    PlainText.test()
    Link.test()
    QuotedString.test()
    InternalPagePath.test()
    ExternalPagePath.test()
    IncludeMacro.test()
    Macro.test()
    Subelement.test()
    Paragraph.test()
    Element.test()
    Document.test()

    text = """
<<Include(Develop/LinkBox)>>
<<Include(Admin/LinkBox)>>
<<Include(FAQs/LinkBox)>>

= Galaxy Administration =
This is the '''hub page''' for the section of ''this wiki'' on how to deploy and administer your own copy of Galaxy.

== Deploying ==

 * [[CloudMan]]
 * [[/GetGalaxy|Install own Galaxy]]
 * [[CloudMan|Install on the Cloud Infrastructure]]
 * [[Admin/Maintenance|Maintaining an Instance]]
 * [[http://deploy.com]]

== Other ==
 * [[Admin/License|License]]
 * [[Admin/RunningTests|Running Tests]]
 * [[Community/GalaxyAdmins|Galaxy-Admins discussion group]]
 * [[Admin/SwitchingToGithubFromBitbucket|Switching to Github from Bitbucket]]

<<div(center)>>
[[http://galaxyproject.org/search/getgalaxy|{{attachment:Images/Logos/GetGalaxySearch.png|Search all Galaxy administration resources|width="120"}}]]

[[http://galaxyproject.org/search/getgalaxy|Search all Galaxy administration resources]]
<<div>>
 
"""

    f = parse(text, Document)

    if args.args.debug:
        print("DEBUG: DOCUMENT UNIT TEST in COMPILED FORMAT:")
        printList(f, 2)

    # What can we do with that parse now that we have it?

    markdownText = compose(f)

    if args.args.debug:
        print("\n====\n====\nDEBUG: DOCUMENT UNIT TEST DONE\n====\n====")

    return
        

# #########################################
# MAIN
# #########################################

args = Argghhs()                          # process command line arguments

if args.args.runtests:
    runTests()


if args.args.moinpage:
    # Read in whole file at once.
    moinFile = open(args.args.moinpage, "r")
    moinText = moinFile.read()
    moinFile.close()

    # Replace the mystery character with a space.
    moinText = re.sub(" ", " ", moinText)

    parsedMoin = parse(moinText, Document)
    if args.args.debug:
        print("DEBUG: DOCUMENT in PARSED FORM:")
        printList(parsedMoin, 2)
        print("====\n====\nEND DOCUMENT in PARSED FORM\n====\n====")

    print(compose(parsedMoin))


    
class Dictionary(List):
    """
    Moin dictionaries generate HTML description lists, and we use them extensively
    with Macros that include parts of other pages.

    TODO: Figure out if stuff in dictionaries should go in YAML.
    """

class WikiWordLinks(List):
    """
    Need to handle Camel Case words that are links.
    """
class CategoryLinks(List):
    """
    What to do with Category links?

    They are WikiWordLinks that start with the word "Category".
    """


