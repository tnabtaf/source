#!/usr/local/bin/python3
# -*- coding: utf-8 -*-
#
# Attempting to parse everything, including whitespace.

import argparse
from pypeg2 import *                           # parser library.
import re
import os

# What are the different types of things we hit in MoinMarkup?




# ################
# Basic Text
# ################

class TrailingWhitespace(List):
    grammar = contiguous(re.compile(r"[ \t\f\v]*\n", re.MULTILINE))

    def compose(self, parser, attr_of):
        return ("\n")


class Punctuation(List):
    """
    Characters that aren't included in plaintext or other tokens

    Matches a single character.
    """
    grammar = contiguous(
        attr("punctuation", re.compile(r"[^\w\s]")))
    

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return(self.punctuation)

        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        # What should work
        parse(".", cls)
        parse("/", cls)

        # What should not work
        testFail(" OK[", cls)
        testFail(" ", cls)
        testFail("<<", cls)
        testFail("Uh-huh, this text does'nt mean anything. [[", cls)
        testFail("}}", cls)


class InlineComment(List):
    """
    Moin inline comments either
      Start with /* and run to the end of the line
      Start with /* and end with */ on the same line

    Markdown does not support comments, but YAML does:
      Comments begin with the number sign ( # ), can start anywhere on a line,
      and continue until the end of the line

    TODO: Investigate putting inline comments in the YAML parts of the files.
    """
    grammar = contiguous(
        "/*",
        attr("comment", re.compile(r".*?(?=\*/|\n)")),
        ["*/", restline])   

    def compose(self, parser, attr_of):
        """
        GFM does not appear to support comments.

        Which is unfortuanate as most of these comments are there for a reason.
        See above TODO.
        """
        return("")

        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        # What should work
        parse("/*\n", cls)
        parse("/* This is a comment */", cls)

        # What should not work
        testFail("*/ Oops comment start backwards */", cls)

class Comment(List):
    """
    Moin comments start with ## in the first two columns.

    Given that PyPeg strips leading whitespace, I'm not sure how to tell when
    lines start with ##.
    """
    grammar = contiguous(
        "##",
        optional(re.compile(r" *"),
            optional(attr("comment", re.compile(r".+")))),
        TrailingWhitespace)
    

    def compose(self, parser, attr_of):
        """
        GFM does not appear to support comments.

        Most were generated by MoinMoin automatically, and arent that helpful anyway.
        """
        return("")

        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        # What should work
        parse("##\n", cls)
        parse("## \n", cls)
        parse("## I sing the body ...\n", cls)
        parse("## page was renamed from Admin/Disk Quotas\n", cls)

        # What should not work
        testFail("# Not a comment", cls)
        testFail("#format\n", cls)

        

# ============
# plain text
# ============

class PlainText(List):
    """
    Text with no special characters or punctuation in it.
    """
    grammar = contiguous(
        attr("text", re.compile(r"[\w \t\f\v]+")))

    
    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return(self.text)
        
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        # What should work
        parse(" Testing with no special terminator", cls)
        parse(" OK DOKE ", cls)

        # What should not work
        testFail(" OK DOKE[[", cls)
        testFail(" OK DOKE]]", cls)
        testFail(" OK DOKE. <<", cls)
        testFail("Uh-huh, this text does'nt mean anything. [[", cls)
        testFail(" OK DOKE}}", cls)
        testFail(" OK DOKE\n NOT! ", cls)

class QuotedString(List):
    """
    String embedded in quotes, single or double.

    Match includes the string.  Does not do the right thing with bolds or
    italics, so they must be matched before this.

    Only called when we expect to have a quoted string (like in a Macro).
    Using this in the general case wreaks havoc because of apostrophes.
    """
    grammar = contiguous(
        attr("quotedText",
             re.compile(r"""(?P<quote>['"])(?P<quotedText>.+?)(?P=quote)""")))


    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return(self.quotedText)

    
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("'Jump'", cls)
        parse('''"I Can't do this no more!"''', cls)
        parse(r'"= LAPTOP WITH BROWSER ="', cls)


class Bold(List):
    """
    3 single quotes start and end bold in moinmoin
    """
    grammar = contiguous("'''")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return("**")
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("'''", cls)


class Italic(List):
    """
    Two single quotes start and stop italics.

    This must be processed after Bold.
    """
    grammar = contiguous("''")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return("*")
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("''", cls)



class CodeBlockStart(List):
    """
    {{{ starts a code block.

    Can also specify language.
    {{{#!highlight ini
    {{{#!csv
    """
    grammar = contiguous(
        "{{{",
        optional("#!",
                 optional("highlight", re.compile(r" +")),
                 attr("format", re.compile(r"[^\s]+"))))

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return("\n```" + self.format)
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("{{{", cls)
        parse("{{{#!csv", cls)
        parse("{{{#!highlight ini", cls)


class CodeBlockEnd(List):
    """
    }}} ends a code block.
    """
    grammar = contiguous("}}}")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return("```\n")
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("}}}", cls)

        


# -------------
# PagePath - defined here instead of in Links b/c of dependencies
# -------------

class InternalPagePath(str):
    """
    path to an internal page.  Can be absolute or relative.

    Internal pages can match on fewer characters than external pages
    Used when we know we have a page name.

    Allowable characters for general URLs are
      ALPHA / DIGIT / "-" / "." / "_" / "~" 
      ":" / "/" / "?" / "#" / "[" / "]" / "@"  - can't handle [] internally
      "!" / "$" / "&" / "'" / "(" / ")"        - can't handle () ...
      / "*" / "+" / "," / ";" / "="            - can't handle ,  ...
      spaces
      % 
    in any combination
    See http://stackoverflow.com/questions/1856785/characters-allowed-in-a-url
    """
    grammar = contiguous(re.compile(r"[\w\-\.~:/?#@!\$&'\*+;= %]+"))


    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("FrontPage/Use Galaxy", cls)
        parse("FrontPage/Use Galaxy#This Part of the page", cls)
        parse("/Includes", cls)


class ExternalPagePath(str):
    """
    path to an external page.  

    Allowable characters are
      ALPHA / DIGIT / "-" / "." / "_" / "~" 
      ":" / "/" / "?" / "#" / "[" / "]" / "@"  - can't handle []
      "!" / "$" / "&" / "'" / "(" / ")"        
      / "*" / "+" / "," / ";" / "="
      spaces
      % 
    in any combination
    See http://stackoverflow.com/questions/1856785/characters-allowed-in-a-url
    """
    grammar = contiguous(re.compile(r"[\w\-\.~:/?#@!\$&'\(\)\*+, ;= %]+"))

    
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("FrontPage/Use Galaxy", cls)
        parse("FrontPage/Use Galaxy#This Part of the page", cls)
        parse("/Includes", cls)
        parse("developers.google.com/+/features/sign-in", cls)



        
# ################
# MACROS
# ################

class NamedMacroParameter(List):
    grammar = contiguous(
        r",", maybe_some(whitespace), name(), maybe_some(whitespace), "=",
        maybe_some(whitespace), QuotedString)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse(", fish='jump'", cls)
        parse(', fish="jump high"', cls)
        parse(', from="= LAPTOP WITH BROWSER ="', cls)


class EmptyMacroParameter(List):
    grammar = contiguous(r",")

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse(",", cls)
        parse(", ", cls)

               
class IncludeMacroParameter(List):
    """
    Include params after the page path can be
      empty
      from="some text"
      to="some text"
    and lots of other things we don't use.
    See https://moinmo.in/HelpOnMacros/Include
    """
    grammar = contiguous([NamedMacroParameter, EmptyMacroParameter, whitespace])

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        NamedMacroParameter.test()
        EmptyMacroParameter.test()
        parse(", fish='jump'", cls)
        parse(", ", cls)


class IncludeMacro(List):
    """
    Include Macros can have one or more params.
      <<Include(FrontPage/Use Galaxy)>>
      <<Include(/Includes, , from="= LAPTOP WITH =\n", to="\nEND_INCLUDE")>>
    The opening and closing << >> will have been stripped before parsing.
    """
    grammar = contiguous(
        "Include(",
        maybe_some(whitespace),
        attr("pagePath", InternalPagePath),
        maybe_some(whitespace),
        attr("params", maybe_some(IncludeMacroParameter)), ")")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        if self.params:
            return("INCLUDE(" + self.pagePath + self.params + ")")
        else:
            return("INCLUDE(" + self.pagePath + ")")

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        InternalPagePath.test()
        IncludeMacroParameter.test()
        parse("Include(FrontPage/Use Galaxy)", cls)
        parse(r'Include(/Includes, , from="= LAPTOP =", to="END_INCLUDE")', cls)
        parse('Include(/Includes, , from="= LAPTOP =\\n", to="\\nEND_INCLUDE")', cls)

class TitleDiv(List):
    """
    Title Div may get special handling because it might affect the YAML.
    """
    grammar = contiguous("title")

    def compose(self, parser, attr_of):
        return("""<div class="title">""")


class SpecialDiv(List):
    """
    Anything parsed by this requires something other than just generating a
    div tag.
    """
    grammar = contiguous(TitleDiv)

class OtherDiv(List):
    """
    Handles div classes that only need a div tag generated.
    """
    grammar = contiguous(
        attr("divClass", re.compile(r"\w+")))
        
    def compose(self, parser, attr_of):
        return("<div class='" + self.divClass + "'>")

        
class DivMacro(List):
    """
    Div Macros can define one or more local styles, or close a div
      <<div(solid blue)>>
      <<div(center)>>
      <<div>> (closing)
    Need to figure out what to do in each situation?  Maybe take advantage of
    CSS that we control?
    """
    grammar = contiguous(
        "div",
        optional("(", [SpecialDiv, OtherDiv],
            maybe_some(omit(whitespace), [SpecialDiv, OtherDiv]),
            ")"))

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        out = ""
        for divClass in self:
            out += compose(divClass)
        if len(self) == 0:
            out = "</div>"
        return(out)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("div(center)", cls)
        parse("div", cls)


class TOCMacro(List):
    """
    TableOfContents Macros insert TOC's.  There ya go.
      <<TableOfContents>>
      <<TableOfContents([maxdepth])>>
      <<TableOfContents(2)>>
    """
    grammar = contiguous(
        "TableOfContents",
        optional(
            "(", optional(attr("maxDepth", re.compile(r"\d+"))), ")"))

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        out = "TABLE_OF_CONTENTS"
        try:
            out += "(" + self.maxDepth + ")"
        except AttributeError:
            pass
        return(out)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("TableOfContents", cls)
        parse("TableOfContents(2)", cls)


class BRMacro(List):
    """
    BR macros insert a new line.
      <<BR>>

    That's it.
    """
    grammar = contiguous("BR")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return("<br />")

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("BR", cls)

            
class Macro(List):
    """
    MoinMoin can have macros link include, or div or TableOfContents.  Sometimes they
    have parameters.
      <<Include(FrontPage/Use Galaxy)>>
      <<div(center)>>
      <<TableOfContents>>
      <<div>>
      <<Include(/Includes, , from="= LAPTOP WITH =\n", to="\nEND_INCLUDE")>>
      TODO
    """
    grammar = contiguous(
        "<<", attr("macro", [TOCMacro, IncludeMacro, DivMacro, BRMacro]), ">>")


    def compose(self, parser, attr_of):
        return(compose(self.macro))
    

    @classmethod
    def test(cls):
        DivMacro.test()
        IncludeMacro.test()
        TOCMacro.test()
        BRMacro.test()
        parse("<<div>>", cls)
        parse("<<div(center)>>", cls)
        parse("<<Include(FrontPage/Use Galaxy)>>", cls)
        parse("<<Include(Develop/LinkBox)>>", cls)
        parse(r'<<Include(/Includes, , from="= LA T =\n", to="\nEN_CL")>>', cls)



    
# ===============
# Section Header
# ===============

class SectionHeader(List):
    """
    Section headers start and end with = signs.  The more signs the smaller the header
      = Top level Header =
      == 2nd level Header ==

    That must be the only thing on the line.  Moin does not like leading or
    trailing spaces.
    """        
    grammar = contiguous(
        attr("depth", re.compile(r"^=+")),
        re.compile(" +"),
        attr("name", re.compile(r".+(?= +=+)")),
        re.compile(r" +=+\n"))

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.

        How can that be dangerous?
        """
        return("#" * len(self.depth) + " " + self.name + "\n")        

        

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        return()
        parse("= A single tool or a suite of tools per repository =\n ", cls)
        parse("= Heading 1 =\n", cls)
        parse("== Heading Too! ==\n", cls)


        
# =============
# Links
# =============


class LinkProtocol(List):
    """
    http, ftp etc.
    """
    grammar = contiguous(
        attr("protocol", re.compile(r"((http)|(https)|(ftp))\://",
                                    re.IGNORECASE)))

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return(self.protocol)
    
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("http://", cls)
        parse("ftp://", cls)
        parse("https://", cls)

    
class ExternalLink(List):
    """
    Links that go outside the wiki.
    """
    grammar = contiguous(
        "[[",
        attr("protocol", LinkProtocol),
        attr("path", ExternalPagePath),
        optional("|", attr("linkText", re.compile(r".+?(?=\]\])"))),
        "]]")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        linkOut = compose(self.protocol) + compose(self.path)
        # Try with link text first
        try:
            out = "[" + self.linkText + "](" + linkOut + ")"
        except AttributeError:
            # err on the safe side
            out = "[" + linkOut + "](" + linkOut + ")" 
        return(out)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        LinkProtocol.test()
        parse("[[http://link.com]]", cls)
        parse("[[ftp://this.here.com/path/file.txt]]", cls)
        parse("[[https://link.com/]]", cls)
        parse("[[http://link.com|Linkin somewhere]]", cls)
        parse("[[ftp://this.here.com/path/file.txt|Text for link.]]", cls)
        parse("[[https://link.com/| Whitespace test ]]", cls)



class InternalLink(List):
    """
    Links that go inside the wiki.

    GFM inverts the syntax of relative and root-derived links, compared to
    MoinMoin.
    In Moin relative links start with "/"
    In GFM relative linking is assumed, and starting a link with "/" may be
    undefined.

    So, this calls for some knowledge of the path to the current page in
    the MoinMoin directory, and the home of th enew page in the Markdown
    directory, to correctly translate.
    TODO
    """
    grammar = contiguous(
        "[[",
        maybe_some(whitespace),
        attr("path", InternalPagePath),
        optional("|", attr("linkText", re.compile(r".+?(?=\]\])"))),
        "]]")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        # Try with link text first
        try:
            out = "[" + self.linkText + "](" + compose(self.link) + ")"
        except AttributeError:
            # err on the safe side
            out = "[" + compose(self.link) + "](" + compose(self.link) + ")" 
        return(out)
    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        # Try with link text first
        try:
            out = "[" + self.linkText + "](" + compose(self.path) + ")"
        except AttributeError:
            # err on the safe side
            out = "[" + compose(self.path) + "](" + compose(self.path) + ")" 
        return(out)

        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("[[/PathToPage]]", cls)
        parse("[[path/file.txt]]", cls)
        parse("[[path/more/path/Page Name]]", cls)
        parse("[[/PathToPage|With Text]]", cls)
        parse("[[path/file.txt|uh-huh!]]", cls)
        parse("[[path/more/path/Page Name|Whitespace test 1]]", cls)
        parse("[[path/more/path/Page Name| Whitespace test 2 ]]", cls)



class ImageLink(List):
    """
    Link that shows an image, rather than text.

    In MoinMoin these look like:
      [[http://address.com|{{attachment:Images/Search.png|Search|width="120"}}]]

    So, it's the 2nd part of the link that tells us this is an image.
      
    See http://stackoverflow.com/questions/30242558/how-do-you-create-a-relative-image-link-w-github-flavored-markdown
    for this Markdown solution:
      [[[/images/gravatar.jpeg]]](http://www.inf.ufrgs.br) 

    Many image links include sizing, and that is not supported in Markdown.
    May just be better to go straight to HTML?
    """
    grammar = contiguous(
        "[[",
        [(attr("protocol", LinkProtocol), attr("linkPath", ExternalPagePath)),
         attr("linkPath", InternalPagePath)],
        "|{{attachment:",
        [(attr("imageProtocol", LinkProtocol), attr("imagePath", ExternalPagePath)),
         attr("imagePath", InternalPagePath)],
        optional(
            "|",
            optional(attr("altText", re.compile(r"[^}|]*"))),
            optional(
                "|",
                attr("imageSize", re.compile(r"[^\}]*")))),
        "}}",
        "]]")

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        # Generate HTML img link as it can deal with alt txt and sizes
        out = "<a href='"
        try:
            out += compose(self.protocol)
        except AttributeError:
            pass
        
        out += self.linkPath + "'>"
        out += "<img src='" + compose(self.imagePath) + "'"
        
        # Add alt text
        try:
            out += " alt='" + self.altText + "'" + compose(self.link) + ")"
        except AttributeError:
            pass
        # other stuff at the end
        try:
            out += " " + self.imageSize
        except AttributeError:
            pass
        out += " /></a>"
                    
        return(out)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse('[[search/getgalaxy|{{attachment:GetGalaxySearch.png}}]]', cls)
        parse('[[http://gp.org/sch/getxy|{{attachment:Im/L/GGS.png|S all}}]]',
              cls)
        parse('[[http://gt.g/gy|{{attachment:Is/L/G.png|s a|width="120"}}]]',
              cls)
        
       

class Link(List):
    """
    Links in Moin are enclosed in [[ ]].  Some have text, some have embedded
    images, and some have extra params.
    """
    grammar = contiguous(
        attr("link", [ImageLink, ExternalLink, InternalLink]))

        
    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        return(compose(self.link))

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        ExternalLink.test()
        InternalLink.test()
        ImageLink.test()
        parse("[[https://developers.google.com/open-source/soc|Google Summer of Code 2015]]", cls)
        parse(" [[http://link.com|Link to here]]", cls)
        parse("[[LinkToPage]]", cls)
        parse("[[LinktoPage|Text shown for link]]", cls)
        parse("[[https://developers.google.com/+/features/sign-in|Google+ sign-in]]", cls)
        parse("[[http://www.citeulike.org/group/16008/order/to_read,desc,|Galaxy papers on CituLike]]", cls)
        parse("[[http://bioblend.readthedocs.org/en/latest/|bioblend]]", cls)

# =============
# Subelements
# =============

class Subelement(List):
    """
    Subelements can occur in paragraphs or table text.

    Subelements can also be elements.
    """
#    grammar = contiguous(
#        [Macro, Link, Bold, Italic, QuotedString, InlineComment,
#         PlainText, Punctuation])
    grammar = contiguous(
        [Macro, Link, Bold, Italic, InlineComment,
         PlainText, Punctuation])
    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        out = ""
        for item in self:
            out += compose(item)
        return(out)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        Link.test()
        Macro.test()
        QuotedString.test()
        PlainText.test()
        Bold.test()
        Italic.test()
        InlineComment.test()
        Punctuation.test()


# ===========
# Lists
# ===========

class BulletListItem(List):
    """
    An individual entry in a bullet list.

    Look like
     * Text here.

    But, can't get pypeg's whitespace to work, so grammar drops spaces.
    That's a problem as we need to know depth.
    """
    grammar = contiguous(
        attr("depth", re.compile(r" *")),
        attr("bullet", re.compile(r"\*")),
        re.compile(r" +"),
        attr("item", some(Subelement)),
        re.compile(r" *"),
        "\n"
        )


    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        out = "* "
        for subelement in self.item:
            out += compose(subelement)
        out += "\n"
        return(out)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse(" * E\n", cls)
        parse(" * Electric boogaloo\n", cls)
        parse(" * A simple case.\n", cls)
        parse(" * A simple case \n", cls)


class BulletList(List):
    """
    Look like
     * Text goes here
     * More text here
    """
    grammar = contiguous(some(BulletListItem))

    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        out = ""
        for item in self:
            out += compose(item)
        return(out)
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        BulletListItem.test()
        parse(" * One Item Only\n", cls)
        parse(" * A simple case.\n * With two items\n", cls)
        parse(""" * A simple case.
   * With nested item
""", cls)
        parse(""" * A simpler case.
   * With nested item
   * and another
""", cls)
        parse(""" * A less simplerer case.
   * With nested item
   * And another
     * and More!
   * Uh huh.
""", cls)



class NumberedListItem(List):
    """
    An individual entry in a numbered list.

    Look like
     1. Text here.
     1. More Here.
    or
     1. Item 1
     2. Item 2
    """
    grammar = contiguous(
        attr("depth", re.compile(r" *")),
        attr("number", re.compile(r"\d+\.")),
        re.compile(r" +"),
        attr("item", some(Subelement)),
        re.compile(r" *"),
        "\n"
        )


    def compose(self, parser, attr_of):
        out = "1. "
        for subelement in self.item:
            out += compose(subelement)
        out += "\n"
        return(out)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse(" 1. E\n", cls)
        parse(" 2. Electric boogaloo\n", cls)
        parse(" 11. A simple case.\n", cls)
        parse(" 12. A simple case \n", cls)


class NumberedList(List):
    """
    Look like
     1. Text goes here
     1. More text here

    TODO: Deal with depth.
    """
    grammar = contiguous(some(NumberedListItem))

    def compose(self, parser, attr_of):
        out = ""
        for item in self:
            out += compose(item)
        return(out)
        
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        BulletListItem.test()
        parse(" 1. One Item Only\n", cls)
        parse(" 2. A simple case.\n 3. With two items\n", cls)
        parse(""" 22. A simple case.
   24. With nested item
""", cls)
        parse(""" 17. A simpler case.
   1. With nested item
   1. and another
""", cls)
        parse(""" 1. A less simplerer case.
   1. With nested item
   1. And another
     1. and More!
   1. Uh huh.
""", cls)


# ================
# Paragraph
# ================

class Paragraph(List):
    """
    Paragraphs are text separated by blank lines or other tokens.
    """
    grammar = contiguous(some(Subelement))

    def compose(self, parser, attr_of):
        out = ""
        for item in self:
            out += compose(item)
        return(out)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("""Let's try plain text first.
        
        """, cls)



# ================
# Elements
# ===============
    
class Element(List):
    """
    An element is anything that can stand on it's own, at the the highest level
    of the Document.

    Elements don't have to be at the top level, but they can be.
    """
    grammar = contiguous(
        [SectionHeader, BulletList, NumberedList, Macro, CodeBlockStart, CodeBlockEnd,
         Comment, Paragraph, TrailingWhitespace])


    def compose(self, parser, attr_of):
        """
        Override compose method to generate Markdown.
        """
        if self[0] is whitespace:
            return(self[0])
        return(compose(self[0]))

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        SectionHeader.test()
        BulletList.test()
        NumberedList.test()
        Macro.test()
        CodeBlockStart.test()
        CodeBlockEnd.test()
        Comment.test()
        Paragraph.test()
        #TrailingWhitespace.test()
            

# =================
# Processing Instructions
# =================


class FormatPI(List):
    grammar = contiguous(
        "#format ",
        attr("format", re.compile(r"[\w/]+")))

    def compose(self, parser, attr_of):
        if self.format == "wiki":
            return("")
        else:
            raise NotImplementedError(self.format + " parsing is not supported.")

#    @classmethod
#    def parse(cls, parser, text, pos):
#        print("YES", text, pos)

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("#format wiki", cls)
        parse("#format text/creole", cls)
        

class RedirectPI(List):
    """
    Not sure what to do with redirects.

    Probably want to have a clean slate as far as redirects go.  Which
    means don't do anything with them.
    """
    grammar = contiguous(
        re.compile(r"#REDIRECT ", re.IGNORECASE),
        attr("redirect", InternalPagePath))

    def compose(self, parser, attr_of):
        raise NotImplementedError("Not generating REDIRECT Pages. Letting them die.")

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("#REDIRECT CloudMan/AWS/AMIs\n", cls)
        parse("#REDIRECT Learn/IntervalOperations", cls)
        parse("#redirect Events/Meetups/Baltimore/20150122", cls)
        parse("#redirect Events/Meetups/Baltimore/2015-01-22", cls)
        parse("#redirect Events/Meetups/Baltimore/2015-01-22\n", cls)
        parse("#redirect Events/Meetups/Baltimore/2015-01-22 \n", cls)

class RefreshPI(List):
    """
    The refresh is effectively a redirect to an external page.

    We aren't propoagating redirects, don't propagate refreshes either.
    """
    grammar = contiguous(
        re.compile(r"#refresh "),
        attr("redirect", restline))

    def compose(self, parser, attr_of):
        raise NotImplementedError("Not generating refresh Pages. Letting them die.")

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("#refresh http:/a.b.c/CloudMan/AWS/AMIs\n", cls)
        parse("#refresh https://Learn/IntervalOperations#fish", cls)

class PragmaPI(List):
    """
    Pragma is used to control some behavious.  The only one we have is

      #pragma section-numbers off    

    I'm going to make an executive decision that we don't care about these
    """
    grammar = contiguous(
        re.compile(r"#pragma "),
        attr("pragma", restline))

    def compose(self, parser, attr_of):
        return("")

    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        parse("#pragma section-numbers off", cls)

        
class ProcessingInstruction(List):
    """
    Happen at top of file.

    Have the form
     #format        - lots 
     #redirect      - lots
     #refresh       - have one of these
     #pragma        - have 2 both are
       #pragma section-numbers off
     #deprecated    - have 0
     #language      - have 51 of these, all en

    Comments, which start with ## are handled elsewhwere.
    """
    grammar = contiguous(
        attr("pi", [FormatPI, RedirectPI, RefreshPI, PragmaPI]))

    
#        attr("pi",[FormatPI, RedirectPI, RefreshPI, PragmaPI, LanguagePI]),

    
    def compose(self, parser, attr_of):
        return(compose(self.pi))
    
    @classmethod
    def test(cls):
        """
        Test different instances of what this should and should not recognize
        """
        FormatPI.test()
        #RedirectPI.test()
        #RefreshPI.test()
        PragmaPI.test()
        parse("#format wiki\n", cls)
        parse("#format text/creole\n", cls)
        
        
class Document(List):
    """
    Parse the whole page.

    Moin pages don't have to contain anything, and most items do not have to be in a
    particular order.

    Does the page arrive as a list of text lines?
    """
    grammar = contiguous(
        maybe_some([ProcessingInstruction, Comment]),
        maybe_some(Element))


    @classmethod
    def test(cls):
        parse("""#REDIRECT CloudMan/AWS/AMIs
""", cls)



# =================================
# Non grammar subs
# =================================

class Argghhs(object):
    """
    Process and provide access to command line arguments.
    """

    def __init__(self):
        argParser = argparse.ArgumentParser(
            description="Convert a single wiki page (a file) from MoinMoin to Github Flavored Markdown. Running this with no params does nothing.  Running with --debug produces a LOT of output. Markdown is sent to stdout.",
            epilog="Example: " + os.path.basename(__file__) +
            " --moinpage=Admin.moin --debug")
        argParser.add_argument(
            "--moinpage", required=False, default=None,
            help="File containing a single MoinMoin page.")
        argParser.add_argument(
            "--runtests", required=False, 
            help="Run Unit Tests.",
            action="store_true")
        argParser.add_argument(
            "--debug", required=False, 
            help="Include debug output",
            action="store_true")
        self.args = argParser.parse_args()

        return(None)


def testFail(testText, cls):
    """
    Run a parse test that should fail.
    """
    try:
        parsed = parse(testText, cls)
        print(parsed)
        print("ERROR: Test that should have failed did not fail.")
        print("Test:")
        print(testText)
        printList(parsed)
        raise BaseException(cls.__name__)
    except (SyntaxError, TypeError):
        pass                              # TypeError is b/c of pypeg bug.
    return()


def printList(list, indent=0):
    for item in list:
        print("." * indent, item)
        if item != None and not isinstance(item, str):
            print("c" * indent, compose(item))
            printList(item, indent+2)
        else:
            print("n" * indent, "None")
    try:
        for name, item in list.__dict__.items():
            if name not in ["position_in_text"]:
                print("d" * indent, name, ":", item)
                if item != None and not isinstance(item, str):
                    if len(item) > 0:
                        print("c" * indent, name, ":", compose(item))
                        printList(item, indent+2)
                else:
                    print("n" * indent, name, ": None")
    except AttributeError:
        pass               # Classes that don't name any attr's have no dict

def runTests():
    global args

    ProcessingInstruction.test()
    BulletList.test()
    SectionHeader.test()
    PlainText.test()
    Link.test()
    QuotedString.test()
    InternalPagePath.test()
    ExternalPagePath.test()
    IncludeMacro.test()
    Macro.test()
    Subelement.test()
    Paragraph.test()
    Element.test()
    Document.test()

    text = """
<<Include(Develop/LinkBox)>>
<<Include(Admin/LinkBox)>>
<<Include(FAQs/LinkBox)>>

= Galaxy Administration =
This is the '''hub page''' for the section of ''this wiki'' on how to deploy and administer your own copy of Galaxy.

== Deploying ==

 * [[CloudMan]]
 * [[/GetGalaxy|Install own Galaxy]]
 * [[CloudMan|Install on the Cloud Infrastructure]]
 * [[Admin/Maintenance|Maintaining an Instance]]
 * [[http://deploy.com]]

== Other ==
 * [[Admin/License|License]]
 * [[Admin/RunningTests|Running Tests]]
 * [[Community/GalaxyAdmins|Galaxy-Admins discussion group]]
 * [[Admin/SwitchingToGithubFromBitbucket|Switching to Github from Bitbucket]]

<<div(center)>>
[[http://galaxyproject.org/search/getgalaxy|{{attachment:Images/Logos/GetGalaxySearch.png|Search all Galaxy administration resources|width="120"}}]]

[[http://galaxyproject.org/search/getgalaxy|Search all Galaxy administration resources]]
<<div>>
 
"""

    f = parse(text, Document)

    if args.args.debug:
        print("DEBUG: DOCUMENT UNIT TEST in COMPILED FORMAT:")
        printList(f, 2)

    # What can we do with that parse now that we have it?

    markdownText = compose(f)

    if args.args.debug:
        print("\n====\n====\nDEBUG: DOCUMENT UNIT TEST DONE\n====\n====")

    return
        

# #########################################
# MAIN
# #########################################

args = Argghhs()                          # process command line arguments

if args.args.runtests:
    runTests()


if args.args.moinpage:
    # Read in whole file at once.
    moinFile = open(args.args.moinpage, "r")
    moinText = moinFile.read()
    moinFile.close()

    # Replace the mystery character with a space.
    moinText = re.sub("Â ", " ", moinText)

    parsedMoin = parse(moinText, Document)
    if args.args.debug:
        print("DEBUG: DOCUMENT in PARSED FORM:")
        printList(parsedMoin, 2)
        print("====\n====\nEND DOCUMENT in PARSED FORM\n====\n====")

    print(compose(parsedMoin))


    
class Dictionary(List):
    """
    Moin dictionaries generate HTML description lists, and we use them extensively
    with Macros that include parts of other pages.

    TODO: Figure out if stuff in dictionaries should go in YAML.
    """

class WikiWordLinks(List):
    """
    Need to handle Camel Case words that are links.
    """
class CategoryLinks(List):
    """
    What to do with Category links?

    They are WikiWordLinks that start with the word "Category".
    """


    
class DoublePipe:
    """
    A double pipe can start a table row, end a table row, or separate table columns.
    """
    grammar = "||"
    
class Table:
    """
    Tables are a series of consecutive rows with each line starting and ending with double
    pipes ||.
    """

